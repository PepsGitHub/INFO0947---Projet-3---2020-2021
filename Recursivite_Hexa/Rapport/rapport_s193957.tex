\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw,dvipsnames]{xcolor}

% Change le nom par défaut des listing
\renewcommand{\lstlistingname}{Extrait de Code}

% Change la police des titres pour convenir à votre seul lecteur
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape}
% Idem pour la table des matière.
\usepackage[nottoc,notlof,notlot]{tocbibind}
\usepackage[titles,subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\newcommand{\coms}[1]{\textcolor{MidnightBlue}{#1}}

\lstset{
    language=C, % Utilisation du langage C
    commentstyle={\color{MidnightBlue}}, % Couleur des commentaires
    frame=single, % Entoure le code d'un joli cadre
    rulecolor=\color{black}, % Couleur de la ligne qui forme le cadre
    stringstyle=\color{RawSienna}, % Couleur des chaines de caractères
    numbers=left, % Ajoute une numérotation des lignes à gauche
    numbersep=5pt, % Distance entre les numérots de lignes et le code
    numberstyle=\tiny\color{mygray}, % Couleur des numéros de lignes
    basicstyle=\tt\footnotesize,
    tabsize=3, % Largeur des tabulations par défaut
    keywordstyle=\tt\bf\footnotesize\color{Sepia}, % Style des mots-clés
    extendedchars=true,
    captionpos=b, % sets the caption-position to bottom
    texcl=true, % Commentaires sur une ligne interprétés en Latex
    showstringspaces=false, % Ne montre pas les espace dans les chaines de caractères
    escapeinside={(>}{<)}, % Permet de mettre du latex entre des <( et )>.
    inputencoding=utf8,
    literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\newcommand{\tablemat}{~}

%%%%%%%%%%%%%%%%% TITRE %%%%%%%%%%%%%%%%
% Complétez et décommentez les définitions de macros suivantes :
\newcommand{\intitule}{Récursivité et Elimination de la Récursivité}
\newcommand{\Prenom}{Peissone}
\newcommand{\Nom}{Dumoulin}
\newcommand{\matricule}{s193957}
% Décommentez ceci si vous voulez une table des matières :
% \renewcommand{\tablemat}{\tableofcontents}

%%%%%%%% ZONE PROTÉGÉE : MODIFIEZ UNE DES DIX PROCHAINES %%%%%%%%
%%%%%%%%            LIGNES POUR PERDRE 2 PTS.            %%%%%%%%
\title{INFO0947: \intitule}
\author{\textsc{\Prenom}~\textsc{\Nom}, \matricule}
\date{}

\begin{document}
\maketitle
\newpage
\tablemat
\newpage
%%%%%%%%%%%%%%%%%%%% FIN DE LA ZONE PROTÉGÉE %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%% RAPPORT %%%%%%%%%%%%%%%
% Complétez les sections ci-dessous

\section{Formulation Récursive}\label{formulation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la formulation récursive du problème
%

\subsection{Cas de base}

Si $n = 1$ :\\

$hexa\_dec\_rec(hexa, n) = convert(hexa[n - 1])$\\

\subsection{Cas récursif}

Si $n > 0$ :\\

$hexa\_dec\_rec(hexa, n) = hexa\_dec\_rec(hexa, n - 1)$\\

\section{Spécification}\label{specification}
%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la spécification formelle de la fonction
% hexa_dec_rec()
%

\begin{lstlisting}
//PréConditions : hexa != NULL, n >= 0
//PostConditions : hexa\_dec\_rec = decimal $\wedge$ hexa = hexa$_0$ $\wedge$ n = n$_0$
unsigned int hexa_dec_rec(char *hexa, int n);
\end{lstlisting}

\section{Construction Récursive}\label{recur}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la construction formelle (avec les assertions
% intermédiaires) de la fonction hexa_dec_rec()
%

\subsection{Programmation Défensive}
On vérifie que la précondition est respectée en interdisant à hexa d'être NULL et n ne peut pas être strictement négatif

\begin{lstlisting}
unsigned int hexa_dec_rec(char *hexa, int n){
    assert(hexa != (void*)0 && n >= 0);
    // \{PréConditions $\equiv$ $hexa \neq$ NULL $\wedge (length(hexa) \geq 0 \implies n \geq 0$)\}
}
\end{lstlisting}

\newpage

\subsection{Cas de Base}
On gère le cas de base où $n = 1$ après s'être assuré que les préconditions sont bien respectées.

\begin{lstlisting}
// \{PréConditions $\equiv$ $hexa \neq$ NULL $\wedge (length(hexa) \geq 0 \implies n \geq 0$)\}
if(n == 1 && i == n){ // i == n permet de différencier le cas de base du cas récursif
    // \{hexa $\neq$ NULL $\wedge$ n = 1 $\wedge$ i = n\}
    if(convert(hexa[n - 1]) != (unsigned int) -1)
    //Vérif de la valur de retour de convert()
        return convert(hexa[n - 1]);
        // \{hexa\_dec\_rec = convert(hexa[n - 1]) $\wedge$ hexa = hexa$_0$ $\wedge$ n = n$_0$\}
        // \{$\implies$ PostCondition\}
    else
        return -1;//dans le cas où l'un des char n'existe pas en hexadécimal
        // \{hexa\_dec\_rec = -1 $\wedge$ hexa = hexa$_0$ $\wedge$ n = n$_0$\}
        // \{$\implies$ PostCondition\}
}
\end{lstlisting}

\subsection{Cas Récursifs}
Il y a un seul cas récursif, selon que n est strictement positif.
\{PréConditions$_{REC}$\} et \{PostConditions$_{REC}$\} sont respectivement les PréConditions et les PostConditions de l'appel récursif.

\begin{lstlisting}
}else if(n > 0){
    // \{hexa $\neq$ NULL $\wedge$ n > 0\}
    if(convert(hexa[n - 1]) != (unsigned int) -1){
    //Vérif de la valur de retour de convert()
        // \{$\implies$ PréConditions$_{REC}$\}
        intermediaire += convert(hexa[n - 1]) * puissance;
        // \{hexa $\neq$ NULL $\wedge$ n > 0 $\wedge intermediaire = intermediaire + convert(hexa[n-1])$\}
        puissance *= 16;
        // \{hexa $\neq$ NULL $\wedge$ n > 0 $\wedge$ $intermediaire = intermediaire + convert(hexa[n-1])$
        // $\wedge$ $puissance = puissance * 16$\}
        i = 2;
        // \{hexa $\neq$ NULL $\wedge$ n > 0 $\wedge$ $intermediaire = intermediaire + convert(hexa[n-1])$
        // $\wedge$ $puissance = puissance * 16$ $\wedge$ $i = 2$\}
        return hexa_dec_rec(hexa, n - 1);
        // \{PostConditions$_{REC}$ $\equiv$ hexa\_dec\_rec = hexa\_dec\_rec $\wedge$ n = n - 1 $\wedge$ hexa = hexa$_0$ \}
        // \{$\implies$ PostConditions\}
    }else
        return -1;//dans le cas où l'un des char n'existe pas en hexadécimal
        // \{hexa\_dec\_rec = -1 $\wedge$ hexa = hexa$_0$ $\wedge$ n = n$_0$\}
        // \{$\implies$ PostConditions\}
}
\end{lstlisting}

\newpage

\subsection{Code complet}

\begin{lstlisting}
unsigned int hexa_dec_rec(char *hexa, int n){
    assert(hexa != (void*)0 && n >= 0);//préconditions
    
    static int puissance = 1, intermediaire = 0, i = 1;
    int decimal;
    
    if(n == 1 && i == n){
        if(convert(hexa[n - 1]) != (unsigned int) -1)
            return convert(hexa[n - 1]);
        else
            return -1;//dans le cas où l'un des char n'existe pas en hexadécimal
    }else if(n > 0){
        if(convert(hexa[n - 1]) != (unsigned int) -1){
            intermediaire += convert(hexa[n - 1]) * puissance;
            puissance *= 16;
            i = 2;
            return hexa_dec_rec(hexa, n - 1);//récursivité
        }else
            return -1;//dans le cas où l'un des char n'existe pas en hexadécimal
    }
    
    decimal = intermediaire;
    puissance = 1;
    intermediaire = 0;
    
    return decimal;//retourne la valeur décimale finale
}
\end{lstlisting}

\section{Traces d'Exécution}\label{traces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici les traces d'exécution de la fonction romain_rec()
% pour les exemples donnés dans l'énoncé
%

% L'exemple ci-dessous donne une trace d'exécution pour un exercice sur les
% Piles (cfr. GameCodes associés).  Inspirez-vous du code LaTeX pour produire
% vos traces d'exécution.
% \begin{tabular}{|c|}
% \\
% \\
% \textcolor{white}{--}\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% \\
% \\
% 20\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% \\
% 4\\
% 20\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% \\
% \\
% 80\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% \\
% 9\\
% 80\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% 7\\
% 9\\
% 80\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% \\
% 16\\
% 80\\
% \hline
% \end{tabular}~~
% \begin{tabular}{|c|}
% \\
% \\
% 5\\
% \hline
% \end{tabular}

\section{Complexité}\label{complexite}
%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la complexité théorique de la fonction
%  hexa_dec_rec()
%

\section{Dérécursification}\label{derecur}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la dérécursification de la fonction hexa_dec_rec()
% Attention, il n'est pas question ici de fournir un algorithme itératif mais
% bien d'éliminer la récursivité comme cela a été vu au cours.
% La solution doit être proposée en utilisant le pseudo-code vu au cours (et
% dans les GameCodes du Chapitre 9).
%

\end{document}
